#!/bin/bash
#common.sh

#############################################
# обработка ошибок
#############################################
on_error() {
  ([[ -n "${tmpfile}" ]]  && [[ -f "${tmpfile}" ]])  && rm "${tmpfile}"
  ([[ -n "${tmpfile1}" ]] && [[ -f "${tmpfile1}" ]]) && rm "${tmpfile1}"
  ([[ -n "${dtr}" ]] && [[ -d "${dtr}" ]]) && rm -r "${dtr}"
  exit 1
}

#############################################
# Вызов справки
#############################################
help() {
  echo "
  Аргументы запуска:
        --add                   - действие 'add', создать новый контейнер
    -a, --alias AliasName       - имя (alias) контейнера
    -b, --backup                - действие 'backup', копия данных из контейнера
    -c, --config-dir DirConf    - каталог с файлами конфигурации и инициализации контейнера
    -d, --delete                - действие 'delete', удалить контейнер
        --debug                 - выводить отладочную информацию
        --debug-level Number    - уровень отладочной информации
    -e, --env EnvName=EnvValue  - значения для переопределния переменных в файлах конфигурации
    -h, --help                  - вызов справки
    -i, --image InageName       - образ, с которого создать контейнер
    -n, --not-backup            - если =0, то бэкап перед удалением контейнера, иначе нет бэкапа. По-умолчанию =0.
    -t, --timeout Number        - период ожидания в сек
    -u, --vaults FileName       - файл со значениями секретных переменных для сборки контейнера, которые не хранятся в git
    -v, --vars FileName         - файл со значениями переменных для сборки контейнера, которые хранятся в git
    -w, --where-copy DirName    - куда сделать бэкап данных из контейнера
    --use-name Number           - <>0 - добавлять в конце к каталогу $where_copy имя контейнера
                                  иначе не добавлять. По-умолчанию = 1
    --use-dir_cfg Number        - <>0 - добавлять в начале к каталогу $DEF_WHERE_COPY $dir_cfg, т.е. каталог будет ($dir_cfg/$DEF_WHERE_COPY),
                                  иначе не добавлять. По-умолчанию = 0
    -x, --export                - экспорт образ контейнера
  "
}

debug() {
  level=$2
  level=${level:=$DEBUG_LEVEL}
  if [[ $DEBUG -ne 0 ]]; then
    echo "deb::: $1"
  fi
}

########################################
# Вывести строку и прервать выполнение скрипта
# Вход:
#     $1 - код строки из массива $msg_arr
#     $2 - дополнительная строка для вывода
########################################
break_script() {
  item_msg_err $1
  [[ -z $2 ]] || echo $2
  exit $1
}

#####################################################
# Проверить существует ли контейнер
# Вход:
#     $1 - имя контейнера
# Выход:
#     =1 - контейнер существует
#     =0 - контейнер не существует
#####################################################
# TODO. Не тспользуется. Можно удалить.
#is_exists_instance() {
#  [[ -z $1 ]] && return 0
#  ret=$(lxc info $1 2> /dev/null)
#  [[ $? -eq 0 ]] && return 1 || return 0
#}

#####################################################
# Вернуть состояние контейнера (STOPPED || RUNNING || NOT_EXISTS)
# Вход:
#     $1 - имя контейнера
# Выход:
#     echo $state - состояние контейнера, (STOPPED || RUNNING || NOT_EXISTS)
#     return 1 - контейнер существует
#     return 0 - контейнер не существует
#####################################################
state_instance() {
  [[ -z $1 ]] && {
    echo 'NOT_EXISTS'
    return 0
  }
  ret=$(lxc info $1 2> /dev/null | grep 'Status:')
  [[ $? -ne 0 ]] && {
    echo 'NOT_EXISTS'
    return 0
  }
  echo $ret | sed -n -e 's/Status:[[:blank:]]*\([[:graph:]]*\)$/\1/p'
  return 1
}

#####################################################
# Проверить контейнер запущен или нет
# Вход:
#     $1 - имя контейнера
# Выход:
#     echo "1" - контейнер запущен
#     echo ""  - контейнер не запущен
#####################################################
is_running_instance() {
  ret=$(state_instance $1)
  [[ "$ret" == "RUNNING" ]] && echo "1" || echo ''
}

########################################
# restart container
# Вход:
#     $1 - имя контейнера
########################################
restart_instance() {
  debug "=== restarting instance"
  state_instance=$(state_instance $1)
  [[ "${state_instance}" != "NOT_EXISTS" ]] && {
     [[ "${state_instance}" -eq "RUNNING" ]] &&  ${lxc_cmd} stop $1
    ${lxc_cmd} start $1
  }
}

########################################
# Сделать рендеринг файла с помощью eval
# Вход:
#     $1 - имя файла для рендеринга
# Выход:
#     строка после рендеринга
########################################
template_render() {
  eval "echo \"$(cat $1)\""  
}

#############################################
# Вернуть часть имени контейнера: имя хоста или имя контейнера.
# host:container
# Вход:
#     $1  - имя контейнера для разбора
#     $2  - что вернуть: имя контейнера или имя хоста
#           ='h' , имя хоста (host)
#           = 'c', имя контейнера (container)
#           иначе, имя контейнера (container)
#           по-умолчанию = 'c', т.е. вернуть имя контейнера
# Выход:
#     echo "host" || echo "container"
#############################################
get_part_from_container_name() {
  host_lxc=$(echo $1 | sed -n -e      's/\(.*\):\(.*\)/\1/p')
  container_lxc=$(echo $1 | sed -n -e 's/\(.*\):\(.*\)/\2/p')
  r=$2
  r=${r:="c"}
  case "$r" in
    'h')  echo $host_lxc;
      ;;
    'c') echo $container_lxc;
      ;;
    *) echo $container_lxc;
      ;;
  esac
}



###########################################################
###########################################################
###########################################################
###########################################################
## TEST
###########################################################
test_common() {
  source ./functions/global_vars.sh

  #restart_instance "lxd-dev:tst23"
  
  get_part_from_container_name 'lxd:con'
}
